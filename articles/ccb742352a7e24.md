---
title: "Riverpod × Hooksを活用して、再利用可能なフォームを作成する"
emoji: "⛳"
type: "tech"
topics: []
published: false
---

## はじめに
新規会員登録やユーザ情報入力時に1画面に複数のフォームを設置することはよくあると思いますが、

そこで今回Riverpodとflutter_hooksを活用して再利用可能なフォームを作成してみました。

Flutterでのフォーム実装は、アプリケーション開発において避けて通れない作業です。しかし、複数のTextEditingControllerを管理することは、コードの可読性を低下させ、メモリリークのリスクを増大させます。この記事では、RiverpodとHooksを組み合わせて、これらの問題を解決する再利用可能なフォームの作成方法を詳細に解説します。

:::message
あくまでも思いつきで作ったものなので参考までに留めて、実際に使う場合は自己責任でお願いします。
:::

## StatefulWidgetで作成する場合
まず、StatefulWidgetで作成した場合

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'custom_text_form.g.dart';

enum TextEditingControllerKey {
  title,
  description,
}

@riverpod
TextEditingController controller(
  ControllerRef ref, {
  required TextEditingControllerKey uniqueKey,
}) =>
    TextEditingController();
```

このプロバイダーは、uniqueKeyをパラメータとして受け取り、それに基づいてTextEditingControllerを生成します。これにより、各フォームフィールドに対して一意のコントローラーを提供することができます。

## CustomTextFormウィジェット

```dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class CustomTextForm extends HookConsumerWidget {
  const CustomTextForm({
    Key? key,
    required this.title,
    this.defaultText,
    required this.uniqueKey,
  }) : super(key: key);

  final String title;
  final String? defaultText;
  final TextEditingControllerKey uniqueKey;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final _controller = ref.watch(controllerProvider(uniqueKey: uniqueKey));

    useEffect(() {
      _controller.text = defaultText ?? '';
      return _controller.dispose;
    }, const []);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: TextStyle(fontWeight: FontWeight.bold)),
        TextFormField(
          controller: _controller,
          decoration: InputDecoration(
            border: OutlineInputBorder(),
            hintText: 'Enter $title',
          ),
        ),
      ],
    );
  }
}
```

CustomTextFormウィジェットは、RiverpodのプロバイダーからTextEditingControllerを取得し、フォームフィールドを構築します。useEffectフックを使用して、ウィジェットが破棄されたときにコントローラーを破棄することで、メモリリークを防ぎます。

## 実際のアプリケーションでの使用例


```dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

void main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Reusable Form Example',
      home: MyFormPage(),
    );
  }
}

class MyFormPage extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Reusable Form Example'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            CustomTextForm(
              title: 'Title',
              defaultText: 'Enter the title here',
              uniqueKey: TextEditingControllerKey.title,
            ),
            SizedBox(height: 20),
            CustomTextForm(
              title: 'Description',
              defaultText: 'Enter the description here',
              uniqueKey: TextEditingControllerKey.description,
            ),
            // 他のフォーム要素を追加...
            ElevatedButton(
              onPressed: () {
                // ここでフォームの値を処理...
              },
              child: Text('Submit'),
            ),
          ],
        ),
      ),
    );
  }
}
```

このコードは、タイトルと説明の入力フィールドを持つフォームを作成し、それぞれにデフォルトテキストを設定しています。また、ユーザーがフォームを送信するためのボタンも配置しています。ボタンが押されたときの処理は、実際のアプリケーションのロジックに応じて追加することができます。

## テストコード
テストコードでは、CustomTextFormウィジェットが期待通りに動作するかどうかを検証します。

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'your_custom_text_form_file.dart'; // Replace with actual file import

void main() {
  group('CustomTextForm Tests', () {
    testWidgets('renders correctly with default text', (WidgetTester tester) async {
      const testKey = TextEditingControllerKey.title;
      const defaultText = 'Default Text';

      await tester.pumpWidget(ProviderScope(
        child: MaterialApp(
          home: CustomTextForm(
            title: 'Test Title',
            defaultText: defaultText,
            uniqueKey: testKey,
          ),
        ),
      ));

      // TextFormFieldを見つけて、デフォルトテキストが設定されていることを確認
      expect(find.byType(TextFormField), findsOneWidget);
      expect(find.text(defaultText), findsOneWidget);

      // テキストを変更して、変更が反映されることを確認
      await tester.enterText(find.byType(TextFormField), 'New Text');
      expect(find.text('New Text'), findsOneWidget);
    });

    // 他のテストケースを追加...
  });
}
```

このテストでは、CustomTextFormが正しくレンダリングされ、デフォルトテキストが設定されていること、そしてユーザーがテキストを入力した際にそれが反映されることを確認しています。

## まとめ
RiverpodとHooksを利用することで、Flutterアプリケーションにおけるフォームの管理を効率化し、コードの複雑さを減少させることができます。このアプローチにより、開発者はより保守しやすく、テストしやすいコードを書くことが可能になります。また、フォームの拡張性と再利用性が向上し、開発プロセスがスムーズになります。

