---
title: "🔐 Flutter×トークンベース認証：具体例で学ぶ安全な実装術"
emoji: "⛳"
type: "tech"
topics: []
published: false
---

## はじめに
モバイルアプリケーションでの認証は、アプリがユーザーに安全で便利な体験を提供する上で欠かせない仕組みです。その中でも「トークンベース認証」は、効率性とスケーラビリティの観点から広く採用されています。ただし、トークンの管理には注意点が多く、適切に行わないと、セキュリティ上のリスクが生じるだけでなく、ユーザー体験にも悪影響を与える可能性があります。

例えば、アクセストークンの有効期限が切れてしまった場合や、リフレッシュトークンが漏洩した場合にどう対応すべきかを考える必要があります。また、トークン管理はアプリ全体の設計とも密接に関連し、適切な実装を選ばなければアプリのパフォーマンスに影響を与える可能性もあります。

この記事では、Flutterを使ったトークンベース認証の基本から、トークン管理の課題、実践的な管理方法、そして注意点について具体的に解説します。

## トークンベース認証とは？
トークンベース認証は、セッションベース認証に代わる形で広まった認証方式です。セッションベース認証では、サーバー側でユーザーのセッション情報を保持していましたが、トークンベース認証ではトークン（文字列）を発行してクライアント側に渡すことで認証情報を管理します。

### アクセストークンとリフレッシュトークンの具体的な違い
アクセストークン
用途: ユーザーが認証済みであることを示すための短期間有効なトークン。APIリクエストの際に付与します。
有効期限: 通常1時間以下に設定。期限が短いため、盗難されても悪用されるリスクが低い。
例: ユーザーデータ取得API、プロフィール更新APIなど。
リフレッシュトークン
用途: アクセストークンが期限切れになった際に、新しいアクセストークンを取得するためのトークン。
有効期限: 数日から数週間（場合によっては数ヶ月）。
特徴: アクセストークンよりも長期間有効であるが、漏洩した場合のリスクが高い。セキュリティ対策として、一度使用したら無効化する設計が推奨される。
Flutterでのトークン管理の課題
トークン管理の課題は、実際の運用シナリオを想定するとより明確になります。以下に具体例を挙げて解説します。

課題1: 安全な保存方法
モバイルアプリでは、トークンをデバイスに保存しなければなりません。しかし、不適切な場所に保存すると、トークンが第三者に漏洩する可能性があります。

誤った保存例
プレーンテキストとして保存（例: SharedPreferences に保存）
ローカルファイルに保存（暗号化されていない）
推奨される保存方法
Secure Storageの使用: flutter_secure_storage パッケージを使うことで、デバイスごとの安全な保存方法（iOSではKeychain、AndroidではEncryptedSharedPreferences）を利用できます。
課題2: アクセストークンの期限切れ対応
アクセストークンには通常、短い有効期限が設定されます。そのため、期限が切れた場合にどのように新しいトークンを取得するかが課題となります。

ユーザーが期限切れを意識しないよう、リフレッシュトークンを使ってバックグラウンドで更新を行う必要があります。
更新に失敗した場合のフォールバック（例: 再ログインを促すUI）が必要です。
課題3: トークンの有効期限管理
有効期限を適切に管理しないと、以下の問題が発生します：

誤ったAPIリクエスト: 期限切れのトークンを使ってAPIリクエストを送り、エラーを受け取る。
パフォーマンスの低下: トークンの再取得が頻繁に発生すると、サーバーやクライアントに負荷がかかる。
トークン管理の具体的な実装方法
1. トークンを発行するAPIの設計
以下は、トークン発行APIのリクエスト・レスポンス例です。

リクエスト例
エンドポイント: POST /auth/login

json
コードをコピーする
{
  "email": "example@example.com",
  "password": "secure_password"
}
レスポンス例
json
コードをコピーする
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR...",
  "refresh_token": "dXNlcmlkOjEyMy4uLg==",
  "expires_in": 3600,
  "refresh_expires_in": 2592000
}
サーバー側の実装ポイント：

アクセストークンは短い有効期限を設定する: 1時間以下が一般的。
リフレッシュトークンはより長い有効期限を持つ: 1ヶ月以上。
続きとして、トークンの保存方法や具体的なコード例、Interceptorの使用例などを詳しく解説しますか？






あなた:
続きを解説してください！
ChatGPT

13 秒の間、思考
続いて、具体的な実装方法について詳しく解説していきます。

トークン管理の具体的な実装方法
1. トークンの保存方法
Secure Storageの利用
トークンをデバイスに安全に保存するためには、flutter_secure_storage パッケージの使用が推奨されます。このパッケージは、プラットフォームごとに適切な方法でデータを暗号化して保存します。

iOS: Keychainに保存
Android: EncryptedSharedPreferencesまたはEncryptedPreferencesに保存
パッケージのインストール
yaml
コードをコピーする
dependencies:
  flutter_secure_storage: ^5.0.2
使用方法
dart
コードをコピーする
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

// インスタンスの作成
final storage = FlutterSecureStorage();

// トークンの保存
Future<void> saveTokens(String accessToken, String refreshToken) async {
  await storage.write(key: 'access_token', value: accessToken);
  await storage.write(key: 'refresh_token', value: refreshToken);
}

// トークンの取得
Future<Map<String, String?>> getTokens() async {
  final accessToken = await storage.read(key: 'access_token');
  final refreshToken = await storage.read(key: 'refresh_token');
  return {'access_token': accessToken, 'refresh_token': refreshToken};
}

// トークンの削除（ログアウト時など）
Future<void> deleteTokens() async {
  await storage.delete(key: 'access_token');
  await storage.delete(key: 'refresh_token');
}
トークンの有効期限の保存
アクセストークンとリフレッシュトークンの有効期限も一緒に保存することで、期限切れのチェックが容易になります。

dart
コードをコピーする
Future<void> saveTokenExpiry(int expiresIn, int refreshExpiresIn) async {
  final accessTokenExpiry = DateTime.now().add(Duration(seconds: expiresIn));
  final refreshTokenExpiry = DateTime.now().add(Duration(seconds: refreshExpiresIn));
  await storage.write(key: 'access_token_expiry', value: accessTokenExpiry.toIso8601String());
  await storage.write(key: 'refresh_token_expiry', value: refreshTokenExpiry.toIso8601String());
}

Future<Map<String, DateTime?>> getTokenExpiry() async {
  final accessTokenExpiryString = await storage.read(key: 'access_token_expiry');
  final refreshTokenExpiryString = await storage.read(key: 'refresh_token_expiry');
  return {
    'access_token_expiry': accessTokenExpiryString != null ? DateTime.parse(accessTokenExpiryString) : null,
    'refresh_token_expiry': refreshTokenExpiryString != null ? DateTime.parse(refreshTokenExpiryString) : null,
  };
}
2. トークンの有効期限チェックと更新
有効期限のチェック
トークンの有効期限を事前にチェックし、期限が切れている場合はリフレッシュトークンを使って新しいアクセストークンを取得します。

dart
コードをコピーする
Future<bool> isAccessTokenExpired() async {
  final expiryData = await getTokenExpiry();
  final accessTokenExpiry = expiryData['access_token_expiry'];
  if (accessTokenExpiry == null) {
    return true; // トークンが存在しない場合も期限切れとみなす
  }
  return DateTime.now().isAfter(accessTokenExpiry);
}

Future<bool> isRefreshTokenExpired() async {
  final expiryData = await getTokenExpiry();
  final refreshTokenExpiry = expiryData['refresh_token_expiry'];
  if (refreshTokenExpiry == null) {
    return true;
  }
  return DateTime.now().isAfter(refreshTokenExpiry);
}
トークンの自動更新
アクセストークンが期限切れの場合、リフレッシュトークンを使って新しいアクセストークンを取得します。

dart
コードをコピーする
Future<String?> getValidAccessToken() async {
  final tokens = await getTokens();
  if (await isAccessTokenExpired()) {
    // リフレッシュトークンも期限切れの場合はログイン画面へリダイレクト
    if (await isRefreshTokenExpired()) {
      await deleteTokens();
      // ナビゲーションでログイン画面へ遷移する処理を追加
      return null;
    }
    // アクセストークンのリフレッシュ
    final newAccessToken = await refreshAccessToken(tokens['refresh_token']!);
    if (newAccessToken != null) {
      await saveTokens(newAccessToken, tokens['refresh_token']!);
      // 新しい有効期限も保存
      // ここでは例としてexpiresInとrefreshExpiresInを固定値としていますが、レスポンスから取得してください
      await saveTokenExpiry(3600, 2592000);
      return newAccessToken;
    } else {
      // リフレッシュに失敗した場合もログイン画面へ
      await deleteTokens();
      // ナビゲーションでログイン画面へ遷移する処理を追加
      return null;
    }
  } else {
    return tokens['access_token'];
  }
}
トークンリフレッシュAPIの呼び出し
dart
コードをコピーする
Future<String?> refreshAccessToken(String refreshToken) async {
  final response = await dio.post('/auth/refresh', data: {
    'refresh_token': refreshToken,
  });
  if (response.statusCode == 200) {
    final data = response.data;
    return data['access_token'];
  } else {
    return null;
  }
}
3. APIリクエストにトークンを自動付与
DioのInterceptorを利用
dio パッケージの Interceptor を使って、すべてのAPIリクエストにアクセストークンを自動的に付与します。また、レスポンスが認証エラー（例えばステータスコード401）の場合には、トークンのリフレッシュを試みます。

dart
コードをコピーする
class AuthInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final accessToken = await getValidAccessToken();
    if (accessToken != null) {
      options.headers['Authorization'] = 'Bearer $accessToken';
    }
    handler.next(options);
  }

  @override
  void onError(DioError err, ErrorInterceptorHandler handler) async {
    // 認証エラーかどうかをチェック
    if (err.response?.statusCode == 401) {
      final tokens = await getTokens();
      if (tokens['refresh_token'] != null && !await isRefreshTokenExpired()) {
        // リフレッシュトークンでトークンを更新
        final newAccessToken = await refreshAccessToken(tokens['refresh_token']!);
        if (newAccessToken != null) {
          await saveTokens(newAccessToken, tokens['refresh_token']!);
          // トークンを更新してリクエストを再試行
          final newRequest = err.requestOptions..headers['Authorization'] = 'Bearer $newAccessToken';
          final response = await dio.fetch(newRequest);
          return handler.resolve(response);
        }
      }
      // トークン更新に失敗した場合はログアウト処理
      await deleteTokens();
      // ナビゲーションでログイン画面へ遷移する処理を追加
    }
    handler.next(err);
  }
}

final dio = Dio();
dio.interceptors.add(AuthInterceptor());
エラー処理とユーザーへの通知
トークンのリフレッシュに失敗した場合、ユーザーに再ログインを促す通知を表示することが重要です。
グローバルなエラーハンドリングを実装し、適切なユーザー体験を提供します。
注意点
1. リフレッシュトークンのセキュリティ
サーバーサイドでの管理: リフレッシュトークンは一度使用したら無効化するようにサーバー側で管理します。
長い有効期限は危険: リフレッシュトークンの有効期限が長すぎると、万が一漏洩した場合のリスクが高まります。適切な有効期限を設定しましょう。
デバイスの紛失対策: デバイスが紛失または盗難に遭った場合、リフレッシュトークンを無効化できる仕組み（例: サーバー側でのトークン失効API）を用意します。
2. アーキテクチャの設計
状態管理ライブラリとの組み合わせ: トークン管理を Riverpod や Provider などの状態管理ライブラリで行う際は、アプリ全体のリビルドを避ける設計に注意します。
分離されたトークン管理クラス: トークンの取得・保存・更新機能を専用のクラスまたはサービスとして分離し、他の部分から独立させます。
3. ユーザー体験の向上
スムーズな再認証: トークンが期限切れになった際、ユーザーが操作中に突然エラーが出ないようにバックグラウンドでトークンの更新を行います。
適切なエラーメッセージ: 再ログインが必要な場合、ユーザーにわかりやすいメッセージを表示します。
まとめ
トークンベース認証は、モバイルアプリにおけるセキュリティの要となる仕組みです。Flutterで安全かつ効率的にトークンを管理するためには、以下のポイントが重要です。

トークンの安全な保存: flutter_secure_storage を使用して、アクセストークンとリフレッシュトークンをデバイスに安全に保存します。
有効期限の適切な管理: トークンの有効期限を事前にチェックし、期限切れ前に更新する仕組みを実装します。
Interceptorによる自動化: APIリクエストにトークンを自動付与し、認証エラー時の再試行を自動化します。
アーキテクチャの工夫: トークン管理を他の状態管理と適切に分離し、アプリのパフォーマンスと可読性を向上させます。
これらの実装を通じて、ユーザーにとって安全で快適なアプリを提供できるでしょう。セキュリティは常に進化する分野なので、最新の情報をキャッチアップしつつ、適切な対策を講じていくことが大切です。

## 参考
https://qiita.com/asagohan2301/items/cef8bcb969fef9064a5c
https://zenn.dev/ad5/articles/fae2e929fca79e
https://dev.classmethod.jp/articles/persistent-login-for-mobileapp/#%25E3%2582%25A2%25E3%2582%25AF%25E3%2582%25BB%25E3%2582%25B9%25E3%2583%2588%25E3%2583%25BC%25E3%2582%25AF%25E3%2583%25B3%25E3%2581%25A8%25E3%2583%25AA%25E3%2583%2595%25E3%2583%25AC%25E3%2583%2583%25E3%2582%25B7%25E3%2583%25A5%25E3%2583%2588%25E3%2583%25BC%25E3%2582%25AF%25E3%2583%25B3%25E3%2581%25AE%25E6%259C%2589%25E5%258A%25B9%25E6%259C%259F%25E9%2596%2593%25E3%2581%25AE%25E6%25B1%25BA%25E3%2582%2581%25E6%2596%25B9